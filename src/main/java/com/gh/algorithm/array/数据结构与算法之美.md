# 数据结构与算法之美   

[^作者：王争]: 

[TOC]

## 基础篇

### 数组

#### **1.数组是什么？**

数组（Array）是一种**线性表数据结构**。它用一组**连续的内存空间**，来存储一组具有**相同类型的数据**。（有序，固定长度）

拓展：

​	**线性表：**

​				线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除	了数组，链表、队列、栈等也是线性表结构。

​	**非线性表：**

​				在非线性表中，数据之间并不是简单的前后关系。比如二叉树、堆、图等

#### **2.特性**

​	连续的内存空间和相同类型的数据 造就了数组 **随机访问**的特性。

```properties
#寻址公式
a[i]_address = base_address + i * data_type_size
#data_type_size 表示数组中每个元素的大小
```

​	数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。二分查找时间复杂度 O(logn)；

缺点：

​	这两个限制也让数组中删除、插入一个数据，变得低效，为了保证连续性，就需要做大量的数据搬移工作。

​	插入/删除的最好情况复杂度O(1)，最坏复杂度O(n),平均时间复杂度 (1+2+…n)/n=O(n)。

优化技巧：

​	a.对于乱序的数组插入操作，比如将m插入k位置，可将k位置数据取出放到数组末尾，将m放入k位置。避免了数据搬移。

​	b.	在不追求数组数据连续行的时候，可以将多次删除集中一起操作，即在数组有足够空间的情况下，先标记删除的数据，空间不足时执行真正的删除操作，这样就减少了删除操作导致的数据搬移。

**这也是 JVM 标记清除垃圾回收算法的核心思想**

注意：

​	警惕数组访问越界问题，对与Java 虚拟机内部有做数组越界检查。

但在C语言中，数组越界是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。

```C
//C 语言数组越界代码
int main(int argc, char argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量 i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为。

#### 3.容器能否完全替代数组？

**容器有哪些：**

List,Set,Map

一般将ArrayList与数组作比较。

**容器的优势：**

个人认为，ArrayList 最大的优势就是可以将很多数组操作的细节封装起来。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是支持动态扩容（空间不足时自动扩容1.5倍）。

**注意**：因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建 容器的时候事先指定数据大小。



**如何选择：**

1. ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。
2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。
3.  当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList<ArrayList<object> > array。

   总结

   对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。

#### 4.为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？

从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用 a 来表示数组的首地址，a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址只需要用这个公式：
$$
a[k]address = baseaddress + k * typesize
$$
但是，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：
$$
a[k]address = baseaddress + (k-1)*typesize
$$
对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。

数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。

不过我认为，上面解释得再多其实都算不上压倒性的证明，说数组起始编号非 0 开始不可。所以我觉得最主要的原因可能是历史原因。

C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。



#### 5.本章总结

数组可以说是最基础、最简单的数据结构。数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适。



#### 6.课后思考

**JVM 的标记清除垃圾回收算法的核心理念**



**二维数组寻址公式**



| List       | 特性                                                         |
| ---------- | ------------------------------------------------------------ |
| ArrayList  | 随机访问速度很快，但是在List中间插入和移除元素时较慢         |
| LinkedList | 特性与ArrayList相反，善于顺序访问，在List中间插入删除代价也较低。但随机访问比较慢，特性集比ArrayList更大。 |
|            |                                                              |

| Set           |                                                              |
| ------------- | ------------------------------------------------------------ |
| HashSet       | 为快速查找儿设计的Set。存入HashSet的元素必须定义HashCose()方法。<br />如果没有其他限制，这应该是我们的首选，因为它对速度做了优化。 |
| TreeSet       | 保持次序的Set，底层为树结构。使用它可以从Set中提取有序的序列。元素必须实现Comparable()接口。 |
| LinkedHashSet | 具有HashSet的查询速度，且内部使用链表维护元素的顺序（插入的顺序）。于是在使用迭代器遍历的时候，结果会按元素插入的次序显示。元素也必须定义hashCode()方法 |
| SortedSet     | 比如TreeSet就是其中一种实现方式。<br />SortedSet中的元素可以保证处于排序状态（按对象的比较函数排序，而不是插入的顺序）。 |

| Map               |                                                              |
| ----------------- | ------------------------------------------------------------ |
| HashMap           | 基于散列表实现（取代HashTable）。插入和查询“键值对”的开销是固定的。可以通过构造器设置容量和负载因子，以调整容器性能 |
| LinkedHashMap     | 类似于HashMap，但是迭代访问时，取得的“键值对”的顺序就是插入的顺序，或者是最近最少使用（LRU）的次序。比HashMap稍慢。在使用迭代器访问时，有更快的速度，因为内部使用链表维护次序。<br />    为提高速度，LinkedHashMap散列化所有的元素，但是在遍历键值对时，却又以元素的插入顺序返回键值对。<br />     可以在构造器中设定LinkedHashMap，使之采用LRU（最近最少使用）算法，所以没有被访问的元素就会出现在队列的前面。对于需要定期清理元素节约空间的程序来说，这个功能就能使程序和容易实现。 |
| TreeMap           | 基于红黑树的实现。查看“键”或“值”时，他们会被排序（具体次序有比较函数决定）。TreeMap特点在于，所得到的结果都是经过排序的。TreeMap是唯一带有subMap()方法的Map，可以返回一个子树 |
| WeakHashMap       | 弱键映射，允许释放映射所指向的对象。是为了一些特殊的问题设计的。如果映射之外没有引用指向某个“键”，这个键就可以被垃圾回收器回收 |
| ConcurrentHashMap | 一种线程安全的Map，不涉及同步锁。                            |
| IdentityHashMap   | 使用==代替equals()对键进行比较的散列映射。也是为解决特殊问题设计的。 |
| SortedMap         | TreeMap是目前SortedMap的一种实现方式，可以确保键处于排序状态。 |

